# JavaScript lesson 6 - 7

## 데이터 타입

데이터 타입은 값이 가지고 있다. 값이 할당되는 시점에 타입이 정해진다.

```
int x; 
// 변수에 int 타입이라는 것을 선언
// 정적타입의 언어 - 언어자체에 타입이 있음
x = true // 에러남
// 변수선언할때 어떤 타입의 목적으로 사용할 지 뚜렷
// 장점 : 언제나 Int 타입인걸 알 수 있음
```

```
var x
// 타입의 의미를 담지않고 변수를 선언한 것
// 동적타입의 언어
// 이리저리 돌려써도 됨.. => 부작용, 확인해보기전까진 타입을 모름
```

`typeof`는 변수의 타입을 알려준다. 정확한 의미 : 변수 x에 할당된 **값의 타입**을 말함

`NaN`은 에러를 최대한 피하기위해서 적용한 어거지 값...



> **암묵적 타입 변화**
>
> ```js
> let foo = 2 * "3"; // 6
> ```
>
> 숫자와 문자를 곱하면 에러가 나야 정상이지만 자바스크립트는 암묵적 타입 변화로 에러를 내지않고 결과를 도출한다. 매우 유연하다고 생각할 수 있지만 타입을 예상하기 어렵기 때문에 실수의 가능성도 높아진다.
>
> 하지만 무조건 적으로 나쁘다고 할 순 없다. 타입 변화를 위해 명시적 타입 변화를 사용하는 경우도 있지만, 암묵적 타입 변화를 사용하여 쉽게 타입을 변화 시킬수 있다.



**[ 데이터타입은 자바스크립트의 특징 ]**

- 원시 타입 : 변경할 수 없는 값

  - 숫자 타입 : 정수, 실수 구분 없이 숫자 타입만 존재

  - 문자열 타입 : 따옴표를 사용 , 0개이상의 문자 

    > 다른언어에서 원시 타입으로 취급안함 왜?
  >
    > 값이 여러개이기 때문.
  
    왜 원시타입일까...?? 단순히 에러를 덜 띄우기위해?

    처음부터 친절한 언어이기때문에 좋은점 중 하나. 하나의 값으로 처리를 한다. 

    ```javascript
  '' // 0개의 문자열
    ```
  
    자바스크립트는 문자열은 유니코드를 사용하고 있다.

    문자열을 만드는 방법 : 따옴표, 쌍따옴표, 백틱

    > 문자열을 리터럴 말고 다른 방법으로 만드는 방법?
  >
    > ```javascript
    > var a = new String('123')
    > ```
    >
    > 은 있지만 뻘짓.
  
  - boolean 타입 : 예약어는 자바스크립트와 개발자가 서로 약속한 것 그래서 true, false라고 작성했을때 불리언 타입이라는 것을 자바스크립트가 안다.

  - null타입 : 값이 없는 변수는 없다. 무슨이유인지 몰라도 값이 없다는 것을 말해주는 것

  - undefined 타입

  - Symbol 타입

- 객체 타입 : 변경할 수 있는 값

  함수, 객체, 정규포현식 등등 여러개가 있을 수 있음



원시 타입과 객체 타입은 성격이 매우 다름. 그래서 구분해 놓음

값을 만들때 목적을 잘 생각해서 타입에 맞게 사용해야함



```javascript
'1'*10 // NaN이 아닌 형변화로 암묵적으로 10이 됨
```



### 1. 숫자 타입

자바스크립트는 타언어와 달리 정수, 실수 모두 숫자 타입으로 존재한다. 

2진수, 8진수, 16진수 상관없이 모두 10진수 숫자 타입으로 저장된다.

###### 🙄 궁금사항

---

**Q.** console.log(3 / 2);     // 1.5 다른언어에서는 어떻게 나오지 ?

**A.** 정수 또는 실수타입에 따라 값이 다름

---

#### 숫자 타입

- Infinity: 양의 무한대
- -Infinity: 음의 무한대
- NaN: 산술 연산 불가 - JS는 대소문자를 구분하기 때문에 대소문자를 구분해서 써야함.



### 2. 문자열 타입

- 문자열 타입은 텍스트 데이터를 나타냄
- 문자열은 0개 이상의 16bit 유니코드 문자들의 집합으로 전세계 대부분의 문자를 표현
- 작은 따옴표, 큰 따옴표, 백틱 안에 텍스트를 넣어 생성
- 타언어에서는 원시타입으로 취급하지 않는다. (C언어 - 배열, Java - 객체)

```js
// 문자열 타입
var string;
string = '문자열'; // 작은따옴표 - 일반적으로 사용
string = "문자열"; // 큰따옴표
string = `문자열`; // 백틱 (ES6)

string = '작은따옴표로 감싼 문자열 내의 "큰따옴표"는 문자열로 인식된다.';
string = '작은따옴표로 감싼 문자열 내의 \큰따옴표\는 문자열로 인식된다.';
string = "큰따옴표로 감싼 문자열 내의 '작은따옴표'는 문자열로 인식된다.";
```

문자열을 따옴표를 달지 않으면 처음과 끝을 잘 알수 없고 식별자와 구별하기 어렵다. 즉, 따옴표를 감싸지 않으면 식별자로 인식한다.



### 3. 템플릿 리터럴

- ES6에서 도입된 방법

- ` `` `

- 멀티라인(줄바꿈) 문자열을 제공 

  그 전에는 이스케이프 시퀀스를 사용했다.

- 문자열 내에 표현식 삽입 가능 (문자열 연결)

  ```js
  var first = 'Ung-mo';
  var last = 'Lee';
  
  // ES5: 문자열 연결
  console.log('My name is ' + first + ' ' + last + '.'); // My name is Ung-mo Lee.
  
  // ES6: 표현식 삽입
  console.log(`My name is ${first} ${last}.`); // My name is Ung-mo Lee.
  ```

  

```javascript
var template = `Template literal`;
// 얘는 멀티로 사용할때 사용하는 것이 좋기때문에 에러는 아니지만 자바스크립트 승질냄
```

개행을 할때 라인 피드와 캐리지 리턴을 같이 할때가 있고 라인 피드만 하는 운영체제가 있었다. 현재 OS, 리눅스는 LF방식을 사용하고 있다. 다른 OS마다 개행방법이 달라서 에디터들이 개행방법을 통일하게 할 수 있다. 

`<pre>`를 사용하면 개행을 그대로 html에 나타난다.



### 4. 불리언 타입

불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐이다.



### 5. undefined 타입

> 왜 만들어졌을까?
>
> 암묵적 초기화를 위한 값 자바스크립트 엔진이 해줌 = 자바스크립트에서 사용하기 위한 값

그러므로 개발자가 인위적으로 할당 할 이유는 없다. `undefied`는 변수를 선언했지만 할당하지 않았다는 것을 뜻하는데 `undefined` 를 재할당 한다면 타개발자가 혼란스러울 수 있다.

```javascript
var foo;
console.log(foo); // undefined

// 초기화가 안됐다????
// 초기화는 되었지만 값이 할당이 안된거 아닌가? 
```

존재하지 않는 프로퍼티에 접근할때 `undefined`가 나옴 



### 6. null 타입

의도적 값이 없다는 값을 표현

```javascript
var foo = 'Lee';

// 이전에 할당되어 있던 값에 대한 참조를 제거. 변수 foo는 더이상 'Lee'를 참조하지 않는다.
// 유용해 보이지는 않는다. 변수의 스코프를 좁게 만들어 변수 자체를 재빨리 소멸시키는 편이 낳다.
foo = null;
```



### 7. symbol 타입

- ES6에서 추가된 7번째 타입
- 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용
- 리터럴이 존재하지 않고 심볼 타입 함수로 생성



### 8. 객체 타입

데이터 타입은 원시 타입이 아닌 모든 타입을 객체 타입이라고 부른다. 



### 9. 데이터 타입의 필요성

#### 9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

- 메모리에 값을 저장할때 확보해야할 **메모리 공간의 크기**를 알아야 함. 

- 값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해

  변수는 메모리 선두 어드레스만 기억하고 있기 때문에 크기를 알아야 함

#### 9.2 데이터 타입에 의한 값의 해석

메모리에 저장된 값 0100 0001을 숫자로 해석하면 65이지만 문자열로 해석하면 ‘A’이다.

- 메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해



### 10. 동적 타이핑

타입을 동적으로 만든다라는 의미 . 자바스크립트는 동적 타이핑이기 때문에 타입을 체크를 해야만 한다. 개발자 입장에서는 편리하지만 타입에 대해 오해를 할 수 있고 메모리 손해를 볼 수 있다(메모리 손해는 현 시점에서 큰타격은 아님).



#### 10.1. 동적 타입 언어와 정적 타입 언어

자바스크립트의 변수는 데이터 타입을 갖을까?

변수는 타입을 갖지 않지만 값은 타입이 갖고 있다.



C나 Java와 같은 정적타입 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류(데이터 타입)을 사전에 선언해야 한다. 이를 명시적 타입 선언이라 한다.

```c
// c 변수에는 1바이트 정수 타입의 값(-128 ~ 127)만을 할당할 수 있다.
char c;

// num 변수에는 4바이트 정수 타입의 값(-2,124,483,648 ~ 2,124,483,647)만을 할당할 수 있다.
int num;
```

[**정적타입 언어**]

- 컴파일을 확인할 때 타입을 체크한다. 
- **변수 선언 시점에 변수의 타입이 결정**되고 변수의 타입을 변경할 수 없다.
- 타입 체크를 통과하지 못했다면 에러가 나며 안정성이 높은 코드를 작성할 수 있다.

[**동적타입 언어**]

- 타입이 동적으로 결정된다. (타입정보다 없다) 
- 자바스크립트 변수는 선언이 아닌 **할당에 의해 타입이 결정**된다. 
- 재할당에 의해 별수의 타입은 언제든지 동적으로 변할 수 있다.



```js
var foo;
console.log(typeof foo);  // undefined

foo = 3;
console.log(typeof foo);  // number

foo = 'Hello';
console.log(typeof foo);  // string

foo = true;
console.log(typeof foo);  // boolean

foo = null;
console.log(typeof foo);  // object

foo = Symbol(); // 심벌
console.log(typeof foo);  // symbol

foo = {}; // 객체
console.log(typeof foo);  // object

foo = []; // 배열
console.log(typeof foo);  // object

foo = function () {}; // 함수
console.log(typeof foo);  // function
```

> `typeof` 는 변수에 할당되어 있는 값의 타입을 반환

재할당은 가급적 안한다. 따라서 필요없는 재할당을 막기위해 `const`키워드를 사용한다.

> 재할당을 사용하는 이유는?
>
> 상태를 유지하기 위해 사용한다. 이땐 재할당을 해야한다.
>
> 필요하면 하지만 불필요할땐 사용하지 않는다.

**변수는 타입이 없지만** 변수는 할당 된 값에 의해서 타입을 알 수 있다.

자바스크립트 동적 타입이기 때문에 변수를 사용할 때 주의해야 한다.  

- 변수는 필요할때만 사용해라 - 타입때문에 오류가 많아 진다.
- 변수는 빨리 죽어야한다.. (null 참고) 오래살면 곤란해.. = resouce를 적용 = 메모리를 사용이 많다. = 메모리 사용을 줄이려면 scoop를 사용한다.
- 전역변수는 우리의 적이다. 적극적으로 최대한 사용 안도록 한다.
- 변수 / 상수 : 재할당이 불필요한 아이들은 상수를 사용한다.
- 변수에 이름을 잘 지어주어야 한다. 안되면 커뮤니케이션 힘듬



## 연산자 

연산을 하려면 대상이 있어야 하는데 그것이 표현식(= 피연산자)이다. 연산자 표현식은 결국 값을 나타낸다. 

피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.

```js
// 산술 연산자
5 * 4 // -> 20
// 문자열 연결 연산자
'My name is ' + 'Lee' // -> 'My name is Lee'
// 할당 연산자
color = 'red' // -> 'red'
// 비교 연산자
3 > 5 // -> false
// 논리 연산자
true && false // -> false
// 타입 연산자
typeof 'Hi' // -> 'string'
```



### 1. 산술연산자

피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우, NaN을 반환한다.

#### 1.1 이항 산술 연산자

피연산자가 두개인 연산자

```js
5 + 2; // -> 7
5 - 2; // -> 3
5 * 2; // -> 10
5 / 2; // -> 2.5
5 % 2; // -> 1
```



#### 1.2 단항 산술 연산자

피연산자가 한개인 연산자

[ `++` / `--` ]

```javascript
var x = 1;

x++; // x = x + 1;
// x를 증가시킨다. 
console.log(x); // 2

// 재할당이 이뤄진다.
```

부수효과가 있다.

가독성을 위해 가급적 사용을 줄이는 것이 좋다.

```javascript
var x = 1;
var result;


// 선할당 후증가
result = x++; // result에 x값이 할당 후 x + 1이 실행된다.
console.log(result, x);	// 1, 2

// 선증가 후할당
result = ++x;
console.log(result, x);	// 3, 3
```

```javascript
// 아무런 효과가 없다.
+10  // 10 
+(-10) // -10

// 문자열을 숫자로 타입 변환한다.
+ '10'; // 10 
// 단항 산술 연산자 뒤에 숫자값이 와야하는데 다른 타입이 왔을 경우 숫자 값으로 암묵적 형변환을 한다. 피연산자를 직접적으로 수정하지 않고 새로운 숫자값을 만든다. 왜냐면 원시값이라 변경불가능하기 때문이다.


// 불리언 값을 숫자로 타입 변환한다.
+true; // 1 
+false; // 0 
```



#### 1.3 문자열 연결 연산자

`+` 두 피연산자 중 하나가 문자열인 경우 문자열로 인식한다. (블로그 참고)

- 산술 연산자의 의미

  피연산자가 숫자일 경우

- 문자열 연결 연산자의 의미

  피연산자 중 하나가 문자열 일 경우

```javascript
// 문자열 연결 연산자
'1' + 2 // '12'
// 만약 숫자로 출력하고 싶었다면 에러지만 에러가 나지 않고 암묵적으로 타입 변화함!

// true는 1로 타입 변환한다.
1 + true; // 2
// 코드에는 문맥이 있으므로 true에는 숫자로 바꾼다.

// null은 0으로 타입 변환된다.
1 + null // 1 : false value라고도 한다.

// undefined는 숫자로 타입 변환되지 않는다.
1 + undefined; // NaN
// 개발자가 숫자로 형변환하길 원했지만 undefined는 숫자로 형태변화를 하지 못한다.. 그렇기때문에 NaN으로 출력
// 0으로 판단된다면 곤란한 일이 생긴다. 무슨일????
```



### 2. 할당 연산자

할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 있다.

| 할당 연산자 | 예     | 동일 표현 | 부수 효과 |
| :---------: | :----- | :-------- | :-------: |
|      =      | x = 5  | x = 5     |     ○     |
|     +=      | x += 5 | x = x + 5 |     ○     |
|     -=      | x -= 5 | x = x - 5 |     ○     |
|     *=      | x *= 5 | x = x * 5 |     ○     |
|     /=      | x /= 5 | x = x / 5 |     ○     |
|     %=      | x %= 5 | x = x % 5 |     ○     |

- `+=` 

  ```javascript
  // +=
  x+ = 5 // x = x + 5
  // 메모리의 공간을 아끼기 위해서 이렇게 사용했지만 지금은 별 효용이 없다.
  ```

- ```javascript
  var str = 'My name is ';
  
  // 문자열 연결 연산자
  str += 'Lee'; // str = str + 'Lee';
  console.log(str); // 'My name is Lee'
  
  // 메모리에 어떻게 적재될까?
  // string
  ```



할당문은 표현식이다. 식으로 평가가 되어지기 때문에 값으로 할당된다.

**[ 연쇄 할당 ]**

```javascript
var a, b, c;

// 연쇄 할당. 오른쪽에서 왼쪽으로 진행.
// ① c = 0 : 0으로 평가된다
// ② b = 0 : 0으로 평가된다
// ③ a = 0 : 0으로 평가된다
a = b = c = 0;
// c 가 평가가 되어야 b가 평가되고 그래야 a가 평가되기때문에 오른쪽에서 왼쪽으로 실행된다.

console.log(a, b, c); // 0 0 0

```



### 3. 비교 연산자

자바스크립트의 독특한 특징 중 하나. 비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다. 비교 연산자는 if문이나 for문과 같은 제어문의 조건시에서 주로 사용한다.

#### 3.1 동등 / 일치 비교 연산자

- `==` 동등 비교

  좌항과 우항이 같냐 틀리냐를 비교 / true와 false로 평가 => 사용 금지!!!! 암묵적 타입 변환하여 비교됨

  ```javascript
  // 동등 비교
  5 == 5; // true
  // 메모리의 주소를 비교한게 아니라 값 자체를 비교했기때문에 true.
  
  // 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.
  5 == '5' // true
  ```

- `===` 일치 비교

  좌항과 우항의 타입변환을 하지 않고 비교
  
  ```js
// 일치 비교
  5 === 5; // -> true
  
  // 암묵적 타입 변환을 하지 않고 값을 비교한다.
  // 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.
  5 === '5'; // -> false
  ```
  
  &#128680; **주의**
  
  NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 `isNaN` 을 사용한다.
  
```javascript
  NaN === NaN; // false : 망측...
```

  > 어떤변수에 의도치 않게 NaN을 담았다.
  >
  > `if( x === NaN ){}`은 항상 `false`이기때문에 `isNaN()`함수를 사용한다.
  >
  > ```javascript
  > isNaN(NaN); // true
  > // NaN이라는 값이 NaN이니?
  > // 응
  > ```
  >
  > 또는 `Object.is` 함수를 사용한다.
  >
  > ```js
  > -0 === +0;         // -> true
  > Object.is(-0, +0); // -> false
  > 
  > NaN === NaN;         // -> false
  > Object.is(NaN, NaN); // -> true
  > ```




#### 3.2. 대소 관계 비교 연산자

| 대소 관계 비교 연산자 | 예제   | 설명                  | 부수 효과 |
| :-------------------: | :----- | :-------------------- | :-------: |
|           >           | x > y  | x가 y보다 크다        |     ✕     |
|           <           | x < y  | x가 y보다 작다        |     ✕     |
|          >=           | x >= y | x가 y보다 크거나 같다 |     ✕     |
|          <=           | x <= y | x가 y보다 작거나 같다 |     ✕     |

```js
// 대소 관계 비교
5 > 0;  // -> true
5 > 5;  // -> false
5 >= 5; // -> true
5 <= 5; // -> true
```



### 4. 삼항조건 연산자

```javascript
var x = 2;

// 문법
// 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
var result = x % 2 ? '홀수' : '짝수' ; 
console.log(result); // 짝수
```

if문 대신 삼항조건 연산자를 할당할때 사용되어진다. `if else` 문이 항상 할당을 하는 것은 아님. 한줄로 만들 수 있을때는 삼항조건이 좋으나 여러줄일때 `if else`를 사용한다.



### 5. 논리 연산자

- `||` 논리합(or)

  둘 중 하나가 true면 true

- `&&` 논리곱(AND)

  어느 한 쪽이라도 false면 false

- `!` 반전(NOT)

  ```js
  // 암묵적 타입 변환
  !'Hello' // false
  !'' // true
  ```

- 단축 평가

  ```js
  // 단축 평가
  'Cat' && 'Dog' ; // Dog : 이표현식에 평가를 완료해준 Dog를 평가하여 값을 나타앰
  'Cat' || 'Dog' ; // Cat : Cat이 true이기때문에 Dog를 보지 않고 true를 실행
  ```

  

### 6. 쉼표 연산자

있으나 가독성이 좋지 않음.

표현식인 문 , 맨뒤에 값으로 평가하기때문

```js
var x, y, z;

x = 1, y = 2, z = 3; // 3
```



### 7. 그룹 연산자

그룹 연산자 `()` 는 피연산자인 표현식을 가장 먼저 평가한다.

```js
10 * 2 + 3; // -> 23

// 그룹 연산자를 사용하여 우선순위를 조절
10 * (2 + 3); // -> 50
```



### 8. typeof 연산자

7개의 타입이 있어 7개의 결과물이 있다라고 생각하겠지만 아니다. `null`이 빠지고 `function`(객체)이 추가되었다. 

만약 변수에 `null`이 있을 경우 `===`으로 비교한다.

선언되지 않은 식별자는 타입 오류가 안나고 `undefined`가 나온다. 

```js
typeof ''              // -> "string"
typeof 1               // -> "number"
typeof NaN             // -> "number"
typeof true            // -> "boolean"
typeof undefined       // -> "undefined"
typeof Symbol()        // -> "symbol"
typeof null            // -> "object" 자바스크립트의 버그
typeof []              // -> "object"
typeof {}              // -> "object"
typeof new Date()      // -> "object"
typeof /test/gi        // -> "object"
typeof function () {}  // -> "function" 함수의 경우에는 object가 아닌 function으로 반환한다.
```



### 9. 지수 연산자

ES7에 도입 되었다.

```javascript
// ES7
2 ** 2; // 4

// ES6
Math.pow(2, 2); // 4
```

최신 문법을 사용하면 바벨이 ES6로 버전다운한다. 오호

음수의 거듭제곱을 할 때는 괄호로 묶어야 한다.

```javascript
-5 ** 2;
// -(5 ** 2) 라고 인식하고 잘못된 값으로 계산한다
(-5) ** 2;
```

모든 연산자에서 지수연산자가 제일 먼저 연산된다.

지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다.

```javascript
2 * 5 ** 2; // -> 50
```



### 10. 그 외 연산자

| 연산자     | 개요                                                        |
| :--------- | :---------------------------------------------------------- |
| ?.         | 옵셔널 체이닝 연산자                                        |
| ??         | null 병합 연산자                                           |
| delete     | 프로퍼티 삭제                                               |
| new        | 생성자 함수를 호출할 때 사용하여 인스턴스를 생성            |
| instanceof | 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별 |
| in         | 프로퍼티 존재 확인                                          |



### 11. 연산자의 부수 효과

일부 연산자는 다른 코드에 영향을 주는 부수 효과(side effect)가 있다.

- 할당(=) 연산자, 
- 증가/감소(++/–) 연산자, 
- delete 연산자

변수의 값이 교체 되느냐 안되는냐를 의미




