# JavaScript lesson 20 - 21

## Stric mode

## 빌트인 객체

### 1. 자바스크립트 객체의 분류

- 표준 빌트인 객체 (standard bulit-in object)

  자바스크립트가 기본적으로 제공하는 것

  모든 전역객체의 프로퍼티로 되어있다.

- 호스트 객체

  환경에 따라 다르다.

  클라이언트 사이드, Node.js에서 표준 빌트인 객체를 포함하여 추가적으로 제공한다.

  W3C에서 관리하다가 워킹그룹???? HTML,CSS를 관리하는 그룹에서 관리한다.

- 사용자 정의 객체

  개발자가 만드는 객체



### 2. 표준 빌트인 객체

| 생성자 함수 객체                               | 생성자 함수가 아닌 객체 |
| ---------------------------------------------- | ----------------------- |
| String, Number, Boolean, Function, Array, Date | Math, Reflect, JSON     |
| 프로토타입 메소드, 정적 메소드 제공            | 정적 메소드만 제공      |

```js
// Array 생성자 함수에 의한 Array 객체(배열) 생성
const arr = new Array(1, 2, 3);
console.log(typeof arr); // object
console.log(arr);        // (3) [1, 2, 3]
```

**🙄 궁금사항**

---

**Q.** `console.log(arr);        // (3) [1, 2, 3]`의 값은 배열타입이니까 `Array [1, 2, 3]`이 나와야하 하는거 아닌가????

**A.** 

---

생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체이다.



### 3. 원시 값과 래퍼 객체

대상 : 문자열, 숫자, 불리언(메서드가 없으므로 `.`을 일이 없다.), 심볼

얘네는 원시값인데 `.`을 찍는 순간 객체로 바꾼다. 얘를 레퍼 객체라고 한다. 

`.` : 프로퍼티 접근 연산자, 토큰`(123).toFiyed()`

`.` : 리터럴의 일부 - `123.1`

```js
// 래퍼객체를 이용하지 않는 FM방식
const str = 'hi';
const str = new String(str);

str.toUpperCase()		// ????
console.log(str)
```

래퍼객체는 내부슬롯에 원시값으로 되돌리기 위해서 원시값을 기억한다. 

```js
// 래퍼 객체에 동적으로 프로퍼티 추가
str.name = 'Lee'; // ② 즉 무의미하다.
// ③ str은 이전의 원시값으로 돌아간다. str.name객체를 아무도 가리키지 않는다.

// 이 시점에 str은 위 코드의 래퍼 객체가 아닌 새로운 래퍼 객체를 가리킨다.
console.log(str.name); // ④ undefined - 없는 프로퍼티에 접근하면 undefined
// ⑤ str은 이전의 원시값으로 돌아간다.
```



### 4. 전역 객체

globalThis로 통일하자. 

window의 이름은 self, this, frames이라고도 불린다.

전역객체의 생성 시점은 가장 먼저 생성된다. 브라우저를 키면 전역 객체부터 만든다. 그 후 빌트인 객체를 생성한다. 빌트인 객체는 전역객체 프로퍼티로 바인딩한다.



**[ 전역 객체의 특징 ]**

- 개발자가 직접 전역 객체를 만들 수 없다.
- 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.

### 4.1 빌트인 전역 프로퍼티

#### 4.1.1 Infinity

#### 4.1.2 NaN

#### 4.1.3 undefined

### 4.2 빌트인 전역 함수

window의 프로퍼티임으로 그만큼 많이 사용한다.? 

#### 4.2.1 eval

사용 ㄴㄴ

함순데 인수를 주는데 인수로 문자열로 준다. 그 문자열이 코드다. 그 문자열 코드를 평가하고 실행한다. 하지만 스코프를 교란시키고 보안에 취약하다.

#### 4.2.2 isFinite

유한하니?

뭐가? - 개발자가 알려주는 수.

인수 - 수

수를 검사해서 유한한지 아닌지 불리언값으로 알려줌

#### 4.2.3 isNaN

왜 필요할까? 

NaN은 NaN과 같지 않으므로 isNaN을 사용해야 한다.

#### 4.2.4 parseFloat

실수로 해석하다. 

어떤 문자열이 주어졌을때 그 문자열을 플로우로 해석한다.

인수 - 문자열

#### 4.2.5 parseInt

인수 - 문자열

문자열을 정수로 해석한다.

리턴수는 10진수로 나옴.

진수......

#### 4.2.6 encodeURI / decodeURI

인코드는 어떤 문자의 형식을 바꾼다.

디코드는 바꾼 형식을 되돌려 놓는다.

URI = URL + URN

브라우저 주소에는 아스키코드만 사용할 수 있다. 아스키코드에는 한글이 없다. 왜 주소창에는 아스키 코드만 사용할수 있을까? HTTP(프로토콜)의 약속이기 때문이다. 팀버너스리가 규약을 만들었다. 아스키 코드에는 한글이 없어서 표시하는 방법은`name=%EC%9D%B4%EC%9B%85%EB%AA%A8&`다.

#### 4.2.7 encodeURIComponent / decodeURIComponent

#### 4.3. 암묵적 전역

```js
var x = 10; // 전역 변수

function foo () {
  // 선언하지 않은 식별자에 값을 할당
  y = 20; // window.y = 20;
}
foo();

// 선언하지 않은 식별자 y를 전역에서 참조할 수 있다.
console.log(x + y); // 30
```

`y = 20;` 원래 에러가 나야하나 window 프로퍼티 동적 추가로 window의 프로퍼티로 추가 된다. 이것을 암묵젹 전역이다.

호이스팅은 변수 또는 함수만 해당한다.









**🙄 궁금사항**

---

**Q.** 함수 호이스팅이란????

**A.** 런타임 이전에 함수선언문에 의해 선언과 할당이 동시에 이뤄지는 것

---

