# JavaScript lesson 24

## 클로저

함수용 프로그래밍 언어에는 클로저라는 개념이 있다. 자바스크립트의 개념이 아니기때문에 ECMAScript 사양에 등장하지 않는다. 

클로저는 함수와 **그 함수가 선언된 렉시컬 환경**과의 조합이다.

`함수가 선언된 렉시컬 환경` = 상위 스코프

함수가 있고 함수의 상위 스코프가 ...

함수가 위치한 곳이 상위 스코프다!!!!

함수객체의 내부슬롯 [[Enviroment]]가 참조 값을 가지고 있는데 그 것은 렉시컬 환경이다.

모든 함수는 클로저다.

그런데 모든 함수는 클로저라고 하지 않는다.????

```js
const x = 1;

function outerFunc() {
  const x = 10;

  function innerFunc() {
    console.log(x); // 10
  }

  innerFunc();
}

outerFunc();
```

`outerFunc` 의 상위 스코프는 전역 실행 컨텍스트.



### 1. 렉시컬 스코프

### 2. 함수 객체의 내부 슬롯 [[Enviroment]]

상위 스코프는 바뀌지 않는다.

Function.enviroment????

### 3. 클로저와 렉시컬 환경

평가되어질때 실행되는 실행컨텍스트의 렉시컬환경이 상위 스코프다.



외부함수가 있고 내부함수가 있는 상황에서

외부함수에서보다 내부함수가 더 오래 살아남아야 하는 상황 = 리턴하는 경우

리턴하면 외부에서 내부를 바라볼 수 있는 환경. 외부에서 내부를 바라보고 있으므로 함수가 종료되어도 렉시컬 환경을 죽지 않는다. 

**[ 클로저 조건 ]**

1. 외부 함수 보다 중첩 함수가 더 오래 생존
2. 1번의 조건을 만족하는 중첩 함수가 외부 함수의 식별자를 참조 한다.

원칙적으로는 모든 함수가 클로저이지만 통상적으로는 이 2가지 조건이 만족해야 클로저라고 부른다.



### 4. 클로저의 활용

상태를 안전하게 유지하기 위해 사용한다.

상태? 변수 num에 1이 할당 되어있다. 현재 num의 상태는 1이다. === 바껴왔는데 현재는 이렇고 미래에 바뀔꺼다라는 뉘앙스

상수? 값이 바뀌지 않는다.

클로저를 사용하려면 즉시 실행 함수를 사용해야한다.

함수를 리턴하려면 함수 객체를 생성해서 리턴해야한다. 평가해서 함수 객체가 되어야 한다. 

```html
<!DOCTYPE html>
<html>
<body>
  <button class="increase">+</button>
  <span class="counter">0</span>

  <script>
    const $counter = document.querySelector('.counter');

    // 버튼이 클릭되면 자유 변수 num을 1 증가 시킨다.
    const increase = (function () {
      // 카운트 상태를 유지하기 위한 자유 변수
      let num = 0;

      return function () {
        $counter.textContent = ++num; // 상태 변경
      };
    }());

    document.querySelector('.increase').onclick = increase;
  </script>
</body>
</html>
```

**[ 클로저 공식 ]**

전역변수를 하나만들었다 - 암묵적 결함 (누구든 참조함)

그래서 전역변수를 안쓰고 싶다 -> 지역변수로 해야함 근데 호출할때마다 선언됨

즉시실행함수로 만든다. 그 즉시실행함수 안에 우리가 유지하고 싶은 변수를 선언한다. 그 다음에 즉시실행함수의 상태를 변경하는 함수를 만들고 걔를 리턴해서 받아줘야함. 그리고 외부에서 호출하면 된다. 