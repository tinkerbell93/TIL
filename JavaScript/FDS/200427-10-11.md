# JavaScript lesson 10 - 11

## 객체 리터럴

### 1. 객체란?

Java - 클래스 기반 객체 지향 언어

C - 절차지향형 또는 명령형

JavaScript - 객체 지향 언어이긴 한데 프로토 타입 기반, 절차지향형, 함수형 

객체란 뭘까......

Object(객체) <=> Subject(주체)

프로그래밍에서의 주체는 프로그래머이고 그 외는 다 객체다. 예시로 프로그래머가 책상을 설명할때, 색상은 베이지색상에 높이는 105m, 너비는 0.5m라고 할 수 있다. 

```javascript
책상 = {
  색상 : 베이지,
  높이 : 105,
  너비 : 0.5
}
```

객체는 0개 이상의 속성(프로퍼티 = 우리가 관심있는 데이터)의 집합이다. 프로퍼티는 키와 값의 쌍이다. 만약 키가 없다면 값에 접근할 수 없다. 

하나이상의 자료를 그룹화 한 것은 자료구조라고 하는데 배열은 순서로 값을 찾을 수 있다. 프로퍼티는 키가 있으므로 키로 값을 접근, 찾을 수 있다.

원시 값을 제외한 나머지 값(함수, 배열, 정규표현식 등)은 모두 객체이다.

미리 약속된 표기법으로 코드를 사용하면 자바스크립트 엔진이 해석하여 값을 만들어주는데 `{}`를 해석하면 객체라고 해석한다.



**🙄 궁금사항**

---

**Q.** null은 typeof로 확인하였을 때, 객체이다. 원시 값이지만 객체일 수도 있을까????

**A.** 자바스크립트의 오류로 tpyeof가 아닌 Isnull????확인

---

객체는 0 개 이상의 프로퍼티 집합이며 프로퍼티란 키(Key)와 값(value)로 구성된다. 자바스크립트에서 사용 할 수 있는 모든 값은 프로퍼티 값이 될 수 있으므로 함수도 프로퍼티 **값**으로 사용할 수 있다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드(method)라고 부른다.

```javascript
var counter = {
  num: 0, // 현재 상태가 0이다 = 언제든 변경 될 수 있다.
  increase: function (){
    this.num++;
  } // 자기의 내부의 상태를 변경할 수 있다. = 자신의 내부를 컨트롤 한다.
};
```

즉 프로퍼티는 객체의 상태를 나타낸다. 객체는 값만 갖는 것이 아닌 값을 컨트롤 할 수 있는 행위(함수)도 갖는다. 



### 2. 객체 리터럴에 의한 객체 생성

다른 언어인 객체를 생성하는 메커니즘은 자바는 클래스로 만든다. 그래서 클래스가 없으면 객체를 만들순 없지만 자바스크립트는 객체를 만들수 있다.

자바스크립트는 프로토타입 기반 객체지향 언어로서 다양한 객체 생성 방법이 존재한다.

**🙄 궁금사항**

---

**Q.** 인스턴스란 클래스에 의해 생성되어 메모리에 저장된 실체???? 인스턴스란 무엇일까

**A.** 붕어빵 틀의 붕어빵..

---

- **객체 리터럴**
- Object 생성자 함수
- 생성자 함수
- Object.create 메소드
- 클래스 (ES6)

```javascript
var person = {
  name: 'Lee',
  // name - 명사로 이름 짓는다,
  sayHello: function () {
  // sayHello - 동사, 동사+목적어로 이름 짓는다.
    console.log(`Hello! My name is ${this.name}.`);
  }
};

console.log(typeof person); // object
console.log(person); // {name: "Lee", sayHello: ƒ}
```

객체 리터럴 내에서 `this`는 자신의 개체를 말한다.

**🙄 궁금사항**

---

**Q.** `sayHello: ƒ`은 함수를 의미하는 건가? 그리고 console.log에는 `{name: "Lee", sayHello: function sayHello() }` 왜 함수명이 찍히는거지????

**A.** 

---

코드블록 `{}`뒤에는 `;`이 오지않지만 객체의`{}` `;`이 온다. 값이 종료되었으니(=문이 종료되었으니) `;`을 사용한다. 

```javascript
var x = {};
```

코드에는 문맥이있는데 값이 오는 문맥이므로 `;`를 사용한다.

```javascript
{}
```

대괄호만 사용했을경우 코드블록이라고 자바스크립트와 약속함.



### 3. 프로퍼티

객체는 프로퍼티의 집합이며 프로퍼티는 키와 값으로 구성된다.

- 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값
- 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값

식별자 네이밍 규칙을 지키지 않아도 되지만 굉장히 귀찮아진다. 식별자는 문자열이지만 식별자 네이밍 규칙에 맞는 이름을 사용하면 따옴표를 생략해도 된다. 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.

```javascript
var person = {
  firstName: 'Ung-mo', // 식별자 네이밍 규칙을 준수하는 프로퍼티 키
  'last-name': 'Lee'   // 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키
};

console.log(person); // {firstName: "Ung-mo", last-name: "Lee"}
```



```javascript
var person = {
  // 프로퍼티 키는 name, 프로퍼티 값은 'Lee'
  name: 'Lee',
  // 프로퍼티 키는 age, 프로퍼티 값은 20
  age: 20
};
```

문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성 할수도 있다.

**🙄 궁금사항**

---

**Q.** 동적으로 생성한다는게 무슨의미이며, 정적으로 생산하는 것은 무엇일까????

**A.** 

---

유사별 객체는 이런 문법을 사용하기 때문에 이 문법을 지원한다.

```javascript
var foo = {
  0: 1,
  1: 2,
  2: 3
};

console.log(foo); // {0: 1, 1: 2, 2: 3}
```



### 4. 메소드

함수는 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있다. 메소드는 프로퍼티의 값이 함수 일 경우를 의미하며 객체에 제한되어 있다.

**🙄 궁금사항**

---

**Q.** 값으로 취급한다. = 값이 평가된다. = 함수는 표현식이다????

**A.** 아니라고 !!!! 함수는 문법이야 문법!!!!!!!!! 표현식 아님

---



### 5. 프로퍼티 접근

프로퍼티 값에 접근하려면 두가지 방법이 있다.

- 마침표 표기법

  ```javascript
  객체.key
  ```

  `.`은 연산자임으로 좌항,우항이 있다. 프로퍼티 접근 연산자라고 불린다. 

  ```javascript
  var person = {
    name : 'Kim',
    address : {
      city : seoul
    }
  }
  
  console.log(person.name.address) // city
  ```

  

- 대괄호 표기법

  ```javascript
  객체로 평가 할 수 있는 표현식['key']
  ```

  대괄호 내에 따옴표를 감싸지 않은 이름을 식별자로 해석한다.



```javascript
var person = {
  name: 'Lee'
};

console.log(person.age); // undefined
```

**🙄 궁금사항**

---

**Q.** 존재하지 않는 프로퍼티에 접근하면 undefined가 할당되는 이유는????

**A.** 문법이니까????

---

```javascript
var person = {
  'last-name': 'Lee',
  1: 10
};

person.'last-name';  // -> SyntaxError: Unexpected string
// name에서 문법오류가 나는 이유는? 
// .다음에는 ''을 사용할수없다. 문법적으로

var foo = 'first-name'
console.log(person[foo]) // undefined
// []는 프로퍼티 키에 접근하는 연산자이다.

console.log(person[1]) // 1
console.log(person['1']) //1
// 내부적으로 문자열로 타입변환 되므로 따옴표로 생략가능한다.

var str = 'Hello';
console.log(str[1]) // e
// 문자열 타입은 원시타입이지만 문자열은 유사배열 객체임으로 객체로 타입변환된다.
```



### 6. 프로퍼티 값 갱신

객체는 재할당 없이도 값이 바뀔 수 있다. 상태변경을 추적하기 어렵다.

이미 존재하는 프로퍼티에 값을 항당하면 프로퍼티 값이 갱신된다.

**🙄 궁금사항**

---

**Q.** 메모리 공간이 새로 생기는 것인가? 아님 같은 공간에서 값이 변경되는 것인가?

**A.** 

---

```javascript
var person = {
  name: 'Lee'
};

// person 객체에 name 프로퍼티가 존재하므로 name 프로퍼티의 값이 갱신된다.
// 재할당이 아닌 프로퍼티 갱신????
person.name = 'Kim';

console.log(person);  // {name: "Kim"}

// 객체의 내용을 재할당 없이 바낀다.

```



### 7. 프로퍼티 동적 생성

```javascript
var person = {
  name: 'Lee'
};

// person 객체에는 age 프로퍼티가 존재하지 않는다.
// 따라서 person 객체에 age 프로퍼티가 동적으로 생성되고 값이 할당된다.
person.age = 20;

console.log(person); // {name: "Lee", age: 20}
```



**🙄 궁금사항**

---

**Q.** 대괄호를 이용해서 프로퍼티 동적 생성은 안될까???? `person['age'] = 18;`

**A.** 

---



### 8. 프로퍼티 삭제

`delete`연산자를 이용하여 삭제한다. 사용하지 않는 것을 권장한다. 왜냐하면 안정성이 보장되지 못한다.

```javascript
var person = {
  name: 'Lee'
};

// 프로퍼티 동적 생성
person.age = 20;

// person 객체에 age 프로퍼티가 존재한다.
// 따라서 delete 연산자로 age 프로퍼티를 삭제할 수 있다.
delete person.age;

// person 객체에 address 프로퍼티가 존재하지 않는다.
// 따라서 delete 연산자로 address 프로퍼티를 삭제할 수 없다. 이때 에러가 발생하지 않는다.
delete person.address;

console.log(person); // {name: "Lee"}
```



### 9. ES6에서 추가된 객체 리터럴의 확장 기능

#### 9.1 프로퍼티 축약 표현

ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일 때, 프로퍼티 키를 생략할 수 있다. 이때 프로퍼티 키는 변수 이름으로 자동 생성된다.

```javascript
// ES5
var x = 1, y = 2;

var obj = {
  x: x,
  y: y
};????

console.log(obj); // {x: 1, y: 2}

// ES6
let x = 1, y = 2;

// 프로퍼티 축약 표현
const obj = { x, y };
// x : x, y : y

console.log(obj); // {x: 1, y: 2}
```



#### 9.2 프로퍼티 키 동적 생성

#### 9.3 메소드 축약 표현

```javascript
// ES5
var obj = {
  name: 'Lee',
  sayHi: function() {
    console.log('Hi! ' + this.name);
  }
};

obj.sayHi(); // Hi! Lee

// ES6
const obj = {
  name: 'Lee',
  // 메소드 축약 표현
  sayHi() {
    console.log('Hi! ' + this.name);
  }
};

obj.sayHi(); // Hi! Lee
```



## 원시 값과 객체의 비교

- 원시 타입의 값 : 변경이 불가능한 값, 원시 타입을 저장하면 **원시 값**이 저장, 메모리 크기 고정
- 객체 타입의 값 : 변경이 가능한 값, 객체 타입을 저장하면 **참조 값**이 저장, 메모리 크기 모름



### 1. 원시 값

#### 1.1 변경 불가능한 값

read only : 읽을 순 있지만 수정할 수 없다. 

**값**(표현식이 참조되서 표현되거나 참조되어 2진수로 메모리에 저장되는 것), **변수**(하나의 값을 저장하기위해 확보한 메모리 공간 자체)

즉, 값 !== 변수. 

변수는 수정할 수 없는 값 자체를 저장하지만 객체는 참조값(주소값)을 저장한다. **변수는 재할당을 못한다는 말이 아님. 재할당은 주소값이 바뀜 **

객체는 주소 값 변경 없이 값을 바꿀 수 있다. 원시값은 주소 값을 바꿀 수 없는 상황에서 값을 변경할 수 없다. 그러므로 원시 값을 추적하는게 더 쉽고 신뢰성이 높다.

그렇다면 객체값과 원시값처럼 변경 불가능한 값이라면? 메모리 공간을 바뀔마다 사용되어야 하니까 메모리 공간을 많이 사용된다. 



#### 1.2 문자열과 불변성

```javascript
var str = ''
str = 'a'
str = 'ab'
str = 'abc' // 다른 언어는 ['a','b','c']라는 각각 문자들로 인식하지만 자바스크립트는 그렇지 않다.
```

```javascript
var str = 'Hello';
str[1] = 'a'

// e가 a로 바뀌지 않는다. 왜냐면 str은 문자열로 유사 배열이고 원시타입이기 때문이다.
```



#### 1.3 값에 의한 전달

```javascript
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy);  // 80

score = 100;

console.log(score); // 100
console.log(copy);  // ? 80
```

원시값은 다른 값을 할당하더라도 기존의 값에 영향을 주지 않는다.



### 2. 객체

객체의 값은 참조 값

원시타입의 값은 자체 값

#### 2.1 변경 가능한 값

객체를 변경 불가능한 값처럼 사용하기위해 Deep copy를 한다면 내부의 객체까지 변경 불가능한 값으로 된다. 

같은 주소를 가르키고 있기때문에 가르키고 있는 객체들은 서로 영향을 받는다. 이것은 부작용이다. 그렇기때문에 변경이 불가능한 값으로 지정하고 싶지만 메모리 공간을 많이 사용되기 때문에 가르키는 참조 값을 갖는다.

#### 2.2 참조의 의한 전달







**🙄 궁금사항**

---

**Q.** 

**A.** 

---





```javascript
var foo = false;
var bar = 0;
var result = foo || bar++; // 이땐 0이겠지??? 0은 맞는데 메모리를 까보지 않는이상 이 순간에 0이 대입되는건 알 수 없어.
console.log(result); // 0


```

```javascript
var foo = false;
var bar = 0;
var result = bar++;  
console.log(result); // 0


```

```javascript
const foo = false;
let bar = 0;
const result = foo || bar++; 
console.log(result); // 0
console.log(bar); // 1
```

