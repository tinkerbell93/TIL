# JavaScript lesson 23

## 실행 컨텍스트

호이스팅이 발생하는 이유

식별자, 스코프

클로저의 동작 방식, 클로저를 이해할 전초전...

태스크 큐와 함께 동작하는 이벤트 핸들러와 비동기(setTimeout 함수) 처리의 동작 방식에 대해 이해



### 1. 소스 코드의 타입

| 소스 코드의 타입         | 설명                                                         | 포함되지 않는 코드                             |                         |
| :----------------------- | :----------------------------------------------------------- | ---------------------------------------------- | ----------------------- |
| 전역 코드(global code)   | 전역에 존재하는 소스 코드를 말한다. **전역 변수**를 관리하기 위해 최상위 스코프인 **전역 스코프 생성**, 전역 객체와 연결 | 전역에 정의된 함수, 클래스 등의 내부 코드      | 전역 실행 컨텍스트 생성 |
| 함수 코드(function code) | 함수 내부에 존재하는 소스 코드를 말한다. 지역 변수와 매개 변수를 관리하기 위해 **지역 스코프 생성**, 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결 | 함수 내부에 중첩된 함수, 클래스 등의 내부 코드 | 함수 실행 컨텍스트 생성 |
| eval 코드(eval code)     | 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스 코드를 말한다. **독자적인 스코프 생성** | -                                              | eval 실행 컨텍스트 실행 |
| 모듈 코드(module code)   | 모듈 내부에 존재하는 소스 코드를 말한다. 모듈 별로 **독립적인 스코프 생성** | 모듈 내부의 함수, 클래스 등의 내부 코드        | 모듈 실행 컨텍스트 실행 |

**[ 소스 코드를 4가지 타입으로 구분하는 이유? ]**

소스 코드의 타입에 따라 **실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문**이다.

실행 컨텍스트가 만들어지는 기준으로 코드를 코드 구분한다.



**[ if, while, for문 등등 은? ]**

얘넨 렉시컬환경만 만들고 실행 컨텍스트는 안만든다. 

그렇다면 let, const로 선언했을때는 코드 블록 스코프가 생기는데 이때는 실행 컨텍스트를 만들까 안만들까???? 안만듬 그러나 렉시컬 환경은 만들어져야 한다. 



코드가 평가되어 실행 컨텍스트가 생성되면 스코프가 생성된다???? 실행 컨텍스트가 생성이 되면이 아니라 렉시컬 환경이 생성이 되면 스코프가 생긴다. 왜냐면 코드 블록 스코프는 실행 컨텍스트는 생성이 되지 않지만 렉시컬 환경은 생성이 되기 때문이다.



**🙄 궁금사항**

---

**Q.** if, while, for문 등 실행 컨텍스트를 만들지 않는 이유는?

**A.** 함수, eval, 모듈, 전역 코드만 실행 컨텍스트를 만들기 때문이다.

---

**Q.** 클래스는 소스 코드 타입에 속해있지 않는데 단독적인 무언가인가???? 일단 클래스란????

**A.** 

---

**[ 전역 코드 ]**

전역 변수는 전역 스코프에 등록되야한다. 식별자는 프로퍼티 키로 등록되고 값은 프로퍼티 value로 저장된다. 결과적으로 자바스크립트의 변수들은 프로퍼티로 관리된다. 

스코프라는 개념은 물리적인 개념으로 존재한다. 

```js
// 등록
let a = 1;
// 선언적 레코드 

var b = 1;
// 전역 스코프에 등록되어진다.
// 전역 객체의 프로퍼티이다.

```

절대 global object와 선언적 레코드는 중복 될 수 없다.

```js
let x = 1;
var x = 10;

// 에러남
// 만약 허용된다면? 식별자가 중복되기 때문에 값을 못찾는다.
```

전역 함수, 전역 객체 관리해야함. 



**[ 함수 코드 ]**

함수 스코프를 만들어야함. 함수 스코프 내에는 매개변수, 변수, arguments 객체, arguments 객체 식별자가 관리 되어야한다.

```js
function foo() {
  // foo 함수 코드
  function bar() {
    // bar 함수 코드
  }
}
```





### 2. 소스 코드의 평가와 실행

소스 코드 평가 => 소스 코드 실행

**[ 소스 코드 평가 ]** 

식별자를 등록하기 위해 이 과정이 필요하다. => 호이스팅과 연관되어있다.

1. 실행 컨텍스트를 생성 : 왜냐면 식별자를 등록할 저장소가 필요하기 때문에

2. 변수, 함수 등의 선언문 만을 먼저 실행

3. 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록

**[ 소스 코드 실행 (런타임) ]**

1. 소스 코드 실행에 필요한 정보, 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 취득
2. 변수 값의 변경과 같은 소스 코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록



### 3. 실행 컨텍스트의 역할

모든 코드가 관리 되어지는 곳

실행 컨텍스트는 소스 코드를 실행하기 위해 **필요한 환경을 제공**하고 **코드의 실행 결과를 실제로 관리**하는 영역이다.

실행 컨텍스트는 **식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘**으로 **모든 코드는 실행 컨텍스트를 통해 실행되고 관리**된다.

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메소드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메소드 호출
console.log(x + y); // 3
```

1. 전역 코드 평가
2. 전역 코드 실행
3. 함수 코드 평가
4. 함수 코드 실행



**[ 실행 컨텍스트 ]**

- 렉시컬 환경

  실별자, 스코프 관리

- 실행 컨텍스트 스택

  코드 실행 순서 관리



### 4. 실행 컨텍스트 스택

실행 컨텍스트는 스택 **자료 구조**로 관리된다. 이를 실행 컨텍스트 스택이라고 부른다. 후입 선출이다.

실행 컨텍스트 스택은 코드가 실행되는 시간의 흐름에 따라 실행 컨텍스트가 추가(push)되고 제거(pop)된다.

push - 코드가 평가 되었다.

pop - 코드가 종료 되었다.

스택 = 그릇, 실행 컨텍스트 = 재료 => 실행 컨텍스트 스택에는 실행 컨텍스트가 들어간다. 

**[ 왜 이런 구조로 관리할까? ]**

현재 실행 중인 실행컨텍스트를 구별해야한다. 실행 컨텍스트가 팝되면 그 아래 되어있던게 최상위가 되면서 현재 실행 중인 실행 컨텍스트를 실행한다..

**실행 컨텍스트 스택은 코드의 실행 순서를 관리한다.** 소스 코드가 평가되면 실행 컨텍스트가 생성되고 실행 컨텍스트 스택의 최상위에 쌓인다. **실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행 중인 코드의 실행 컨텍스트이다.** 따라서 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트를 **실행 중인 실행 컨텍스트(running execution context)**라 부른다.



### 5. 렉시컬 환경

렉시컬 환경은 스코프를 나타내는 객체이다.

렉시컬 환경은 상위 스코프에 대한 참조를 가진다.

```
// 의사 코드
EC = {
	VariableEnviroment : ooo,
	LexicalEnvirioment : ooo
}

ooo 은 Lexical Enviroment를 가리킨다. 가리키는 이유는 문법임
스코프의 원인
```

실행 컨텍스트는 렉시컬 환경을 가리킨다.

렉시컬 환경(Lexical Environment)은 식별자와 식별자에 바인딩된 값 그리고 상위 스코프에 대한 참조를 기록하는 환경으로 실행 컨텍스트를 구성하는 컴포넌트이다.

**🙄 궁금사항**

---

**Q.** 컴포넌트란?

**A.** 구성원

---

렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체이다.



**[ 실행 컨텍스트의 구성 ]**

- Lexical Environment 컴포넌트
- VariableEnvironment 컴포넌트

생성 초기 Lexical Environment 컴포넌트와 VariableEnvironment 컴포넌트는 하나의 동일한 **렉시컬 환경**을 참조한다. 이후, 몇가지 상황을 만나면 새로운 렉시컬 환경을 생성하고 이때부터 각 컴포넌트의 내용이 달라지는 경우도 있다.



**[ 렉시컬 환경의 구성 ]**

- 환경 레코드 (Environment Record)

  스코프에 포함된 **식별자를 등록**하고 **등록된 식별자에 바인딩된 값을 관리하는 저장소**이다. 

- 외부 렉시컬 환경에 대한 참조 (Outer Lexical Environment Reference)

  외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킨다.

  이때 상위 스코프란 외부 렉시컬 환경, 즉 해당 실행 컨텍스트를 생성한 소스 코드를 포함하는 상위 코드의 렉시컬 환경을 말한다. 외부 렉시컬 환경에 대한 참조를 통해 단방향 링크드 리스트인 스코프 체인을 구현한다.



### 6. 실행 컨텍스트의 생성과 식별자 검색 과정

```js
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // 42
```

브라우저 키면 윈도우(전역) 객체 생성 => 윈도우 객체 프로퍼티 생성 (표준 빌트인 생성) : 객체를 만들어야함으로 매우 바쁨 => 전역코드 평가 : 전역 실행 컨텍스트 생성, 실행 컨텍스트 스택에 실행 컨텍스트 push, 현재 실행중인 실행 컨텍스트임, 프로퍼티를 추가하면서 값을 할당하는데 그 값은 전역 렉시컬 환경임. 프로퍼티 두개에 바인딩한다.???? 빈객체인데.. 비어 있으면 안되고 환경 레코드와 외부 렉시컬 환경에 대한 참조... 놓침...

#### 6.1 전역 객체 생성

전역 객체는 전역 코드가 평가되기 이전에 생성된다.

전역 객체도 Object.prototype을 상속받는다. 즉, 전역 객체도 프로토타입 체인의 일원이다.

#### 6.2 전역 코드 평가

**[ 전역 코드 평가 순서 ]**

```
1. 전역 실행 컨텍스트 생성
2. 전역 렉시컬 환경 생성
   2.1 전역 환경 레코드 생성
   		2.1.1 객체 환경 레코드 생성
   		2.1.2 선언적 환경 레코드 생성
   2.2 외부 렉시컬 환경에 대한 참조 할당
   2.3 this 바인딩
```

1. **전역 실행 컨텍스트 생성**

   전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시한다.

   

2. **전역 렉시컬 환경 생성**

   전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트의 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트에 바인딩한다.

   

   **2.1 전역 환경 레코드 생성**

   - 객체 환경 레코드

     var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수 그리고 표준 빌트인 객체, 전역 빌트인 프로퍼티 및 메소드를 관리

   - 선언적 환경 레코드

     let, const 키워드로 선언한 번역 변수를 관리

     

     **2.1.1객체 환경 레코드 생성**

     전역 환경 레코드를 구성하는 컴포넌트인 객체 환경 레코드는 BindingObject라고 부르는 객체와 연결된다.

     전역 코드 평가 과정에서 var 키워드로 선언한 **전역 변수**와 함수 선언문으로 정의된 **전역 함수**는 전역 환경 레코드의 객체 환경 레코드에 연결된 **BindingObject를 통해 전역 객체의 프로퍼티와 메소드가 된다.** 

     

     **2.1.2. 선언적 환경 레코드 생성**

     let, const 키워드로 선언한 변수이므로 전역 객체의 프로퍼티가 되지 않기 때문에 전역 객체의 프로퍼티로서 참조할 수도 없다. 

   

   **2.2. 외부 렉시컬 환경에 대한 참조 할당**

   현재 평가 중인 코드를 포함하는 외부 코드의 렉시컬 환경, 즉 상위 스코프를 가리킨다. 

   

   **2.3. this 바인딩**

   전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다. 일반적으로 전역 코드에서 this는 전역 객체를 가리키므로 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에는 전역 객체가 바인딩된다.

   

#### 6.3 전역 코드 실행

전역 코드가 순차적으로 실행되기 시작.
**식별자 결정을 위해 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작한다.** 선언된 식별자는 실행 컨텍스트의 렉시컬 환경의 환경 레코드에 등록되어 있다.



#### 6.4 foo 함수 코드 평가

```js
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // ← 호출 직전
```

foo 함수가 호출되면 전역 코드의 실행을 일시 중단하고 foo 함수 내부로 코드의 제어권이 이동한다. 그리고 함수 코드를 평가하기 시작한다. 

**[ 함수 코드 평가 순서 ]**

```
1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성
  2.1. 함수 환경 레코드 생성
  2.2. 외부 렉시컬 환경에 대한 참조 할당
  2.3. this 바인딩
```



#### 6.5 foo 함수 코드 실행

식별자 결정을 위해 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색하기 시작한다.

#### 6.6 bar 함수 코드 평가

```js
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10); // ← 호출 직전
}

foo(20);
```



#### 6.7 bar 함수 코드 실행

- 실별자 console 검색

  현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 검색.

  현재 실행 중인 실행 컨텍스트에서 찾지 못한다면 **외부 렉시컬 환경에 대한 참조가 가리키는 foo 함수 렉시컬 환경으로 이동**하여 console식별자 검색.

  또 없다면 스코프 체인 상의 상위 스코프로 이동하여 console 식별자 검색

  찾음

- log 메소드 검색

  console 객체에서 log 메소드를 검색

- 표현식 a + b + x + y + z 평가

  현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 시작하여 외부 렉시컬 환경에 대한 참조로 이어지는 렉시컬 환경의 연속에서 검색

  

#### 6.8 bar 함수 코드 실행 종료

bar 함수 실행 컨텍스트가 소멸되었다 하더라도 만약 bar 함수 렉시컬 환경을 누군가 참조하고 있다면 bar 함수 렉시컬 환경은 소멸하지 않는다.



#### 6.9. foo 함수 코드 실행 종료



#### 6.10. 전역 코드 실행 종료



### 7. 실행 컨텍스트와 블록 레벨 스코프

let, const 키워드로 선언한 변수는 모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등)을 지역 스코프로 인정하는 블록 레벨 스코프(block-level scope)를 따른다.





결론 : 

모든 코드 블록이 실행 컨텍스트를 만드는 것이 아니다. 그 외의 스코프를 만드는 것이 있는데 코드 블록을 사용하는 것이 다다. 그 코드 블록안에 let, const 식별자가 있는 경우에서만이다. 단 for문은 조금 특이하다...













**🙄 궁금사항**

---

**Q.** 

**A.** 

---













