# 3. 타입의 모든 것

> **타입 (Type)**
>
> 값과 이 값으로 할 수 있는 일의 집합

타입검사기를 통해 유효하지 않은 동작이 실행되는 일을 예방한다.



## 3.1 타입을 이야기하다

타입 어노테이션이 없으면 함수의 매개변수에 제한이 없으므로 아무 타입이나 인수로 전달 할 수 있다. 일단 타입을 제한하면 타입스크립트가 함수를 호출할 때 호환이 되는 인수로 호출했는지 판단한다.



## 3.2 타입의 가나다

### 3.2.1 any

- 모든 타입의 상위이며 `any` 로 뭐든지 할 수 있지만 필요한 상황에만 사용하는 것을 추천
- **프로그래머와 타입스크립트 둘 다 타입을 알 수 없는 상황에서만 사용**

```typescript
let a: any = 666;		// any
let b: any = ['danger'];	// any
let c = a + b;		        // any
```



### 3.2.2 unknown

- 타입을 미리 알 수 없을 때 `any` 대신 `unknown` 사용
- `unknown` 의 타입을 검사해 정제하기 전까지는 타입스크립트가 `unknown` 타입의 값을 사용할 수 없게 강제한다
- 비교연산(`==, ===, ||, &&, ?`)과 반전(`!`) 을 지원하고 자바스크립트의 `typeof`, `instanceof`여ㄴ산자로 정제할 수 있다.

- TS가 무언가의 타입을 `unknown`이라고 추론하는 상황은 없다.

- `unknown` 타입이 아닌 값과 `unknown` 타입인 값을 비교할 수 있다.

- `unknown` 값이 특정 값이라고 가정하고 해당 타입에서 지원하는 동작을 수행 할 수 없다.

  단, 해당 값이 특정 타입임을 증명하면 가능 (`typeof`)



### 3.2.3 boolean

- `true`, `false` 두 개의 값을 갖는다.
- 비교연산, 반전 연산을 할 수 있다.

```typescript
let a = true;	// boolean
// 어떤 값이 boolean인지 타입스크립트가 추론하게 한다.

const b = true;	// true
// 어떤 값이 특정 boolean인지 타입스크립트가 추론하게 한다.
```

`const` 를 사용하여 TS가 그 변수의 값이 절대 변하지 않으리라는 사실을 알게 되어 해당 변수가 가질 수 있는 가장 좁은 타입으로 추론한다.

> **타입리터럴**
>
> 오직 하나의 값을 나타내는 타입
>
> 타입 리터럴은 모든 곳에서 일어날 수 있는 실수를 방지해 안전성을 추가로 확보해주는 강력한 언어 기능
>
> `let e: true = true`



### 3.2.4 number

- 모든 숫자(정수, 소수, 양수, 음수, Infinity, NaN 등)의 집합이다. 
- `+, -, %, <` 등 숫자 관련 연산을 수행할 수 있다.
- `number` 타입은 대개 TS가 추론하도록 만든다.











